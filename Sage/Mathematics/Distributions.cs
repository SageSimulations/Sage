/* This source code licensed under the GNU Affero General Public License */

using System;
using System.Reflection;
using Trace = System.Diagnostics.Debug;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Highpoint.Sage.SimCore;
using Highpoint.Sage.Randoms;
using Highpoint.Sage.Utility;
// ReSharper disable MemberCanBeProtected.Global
// ReSharper disable InvertIf

// ReSharper disable UnusedParameter.Local
// ReSharper disable ConvertToAutoPropertyWhenPossible
// ReSharper disable UnusedMember.Local
// ReSharper disable CompareOfFloatsByEqualityOperator // TODO: This needs to be addressed.

namespace Highpoint.Sage.Mathematics {

    /// <summary>
    /// The IDoubleDistribution interface produces a sequence of values. They are 
    /// generated by a class that ensures that the values that are generated
    /// conform to a particular distribution.
    /// </summary>
    public interface IDoubleDistribution : IModelObject {
        /// <summary>
        /// Returns the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        double GetNext();

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        double GetValueWithCumulativeProbability(double probability);


        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        void SetCDFInterval(double low, double high);
    }

    /// <summary>
    /// The ITimeSpanDistribution interface produces a sequence of TimeSpan values.
    /// They are generated by a class that ensures that the values that are generated
    /// conform to a particular distribution.
    /// </summary>
    public interface ITimeSpanDistribution : IModelObject {

        /// <summary>
        /// Gets the next value in this distribution.
        /// </summary>
        /// <returns>The next value in this distribution.</returns>
        TimeSpan GetNext();

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what duration will, with 90% certainty, always be greater than or equal
        /// to a duration returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        TimeSpan GetValueWithCumulativeProbability(double probability);

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        void SetCDFInterval(double low, double high);

    }

    /// <summary>
    /// A distribution that uses an underlying <see cref="Highpoint.Sage.Mathematics.IDoubleDistribution"/> to
    /// generate a distribution of TimeSpans.
    /// </summary>
    public class TimeSpanDistribution : ITimeSpanDistribution {

        /// <summary>
        /// The units of a TimeSpanDistribution. The values are according to the underlying IDoubleDistribution, and 
        /// the units are according to the selected element of this enumeration.
        /// </summary>
        public enum Units {
            /// <summary>
            /// Seconds 
            /// </summary>
            Seconds,
            /// <summary>
            /// Minutes
            /// </summary>
            [DefaultValue]
            Minutes,
            /// <summary>
            /// Hours
            /// </summary>
            Hours,
            /// <summary>
            /// Days
            /// </summary>
            Days
        };

        #region Private Fields
        private Units m_units;
        private IDoubleDistribution m_baseDistribution;

        #endregion

        /// <summary>
        /// Creates a new instance of the <see cref="T:TimeSpanDistribution"/> class.
        /// </summary>
        /// <param name="distribution">The underlying IDoubleDistribution that will generate the values in this TimeSpanDistribution.</param>
        /// <param name="units">The units that will be applied to the values out of the underlying IDoubleDistribution.</param>
        public TimeSpanDistribution(IDoubleDistribution distribution, Units units)
            :this(null,"",Guid.Empty,distribution,units)
        {
        }

        /// <summary>
        /// Creates a new instance of the <see cref="T:TimeSpanDistribution"/> class.
        /// </summary>
        /// <param name="model">The model in which this TimeSpanDistribution will exist.</param>
        /// <param name="name">The name of this TimeSpanDistribution.</param>
        /// <param name="guid">The GUID of this TimeSpanDistribution.</param>
        /// <param name="distribution">The underlying IDoubleDistribution that will generate the values in this TimeSpanDistribution.</param>
        /// <param name="units">The units that will be applied to the values out of the underlying IDoubleDistribution.</param>
        public TimeSpanDistribution(IModel model, string name, Guid guid, IDoubleDistribution distribution, Units units) {
            m_baseDistribution = distribution;
            m_units = units;
            // ReSharper disable once InvertIf
            if (Model != null) {
                Model.ModelObjects.Remove(Guid);
                Model.ModelObjects.Add(Guid, this);
            }
        }

        /// <summary>
        /// Gets or sets the base distribution.
        /// </summary>
        /// <value>The base distribution.</value>
        IDoubleDistribution BaseDistribution {
            get { return m_baseDistribution; }
            set { m_baseDistribution = value; }
        }

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new TimeSpanDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public TimeSpanDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.TimeSpanDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this TimeSpanDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this TimeSpanDistribution.</param>
        /// <param name="description">The description of this TimeSpanDistribution.</param>
        /// <param name="guid">The GUID of this TimeSpanDistribution.</param>
        /// <param name="distribution">The GUID of the underlying double distribution which drives this TimeSpanDistribution.</param>
        /// <param name="units">The units (minutes, seconds, etc) that are applied to the underlying double distribution in deriving this TimeSpanDistribution's timespans.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Base distribution", RefType.Owned, typeof(IDoubleDistribution), "The double distribution that provides the profile of this TimeSpan distribution.")]
			Guid distribution,
            [InitializerArg(1, "TimeUnits", RefType.Owned, typeof(Units), "An enumeration - Seconds, Minutes, Hours, or Days.")]
			Units units) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, distribution, units.ToString());
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_baseDistribution = (IDoubleDistribution)m_model.ModelObjects[p[0]];
            m_units = (Units)Enum.Parse(typeof(Units), (string)p[1]);
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model to which this distribution belongs.</param>
        /// <param name="name">The name of the distribution.</param>
        /// <param name="description">The description of the distribution.</param>
        /// <param name="guid">The GUID of the distribution.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }
        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this object. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;

        private string m_description = "A Timespan Distribution";
        /// <summary>
        /// A description of this Timespan Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this object. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion

        #region ITimeSpanDistribution Members

        /// <summary>
        /// Gets the next value in this distribution.
        /// </summary>
        /// <returns>The next value in this distribution.</returns>
        public TimeSpan GetNext() {
            double d = m_baseDistribution.GetNext();
            return GetTimeSpanFor(d);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what duration will, with 90% certainty, always be greater than or equal
        /// to a duration returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public TimeSpan GetValueWithCumulativeProbability(double probability) {
            return GetTimeSpanFor(m_baseDistribution.GetValueWithCumulativeProbability(probability));
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            m_baseDistribution.SetCDFInterval(low, high);
        }


        #endregion

        private TimeSpan GetTimeSpanFor(double randomVar) {
            switch (m_units) {
                case Units.Minutes:
                    randomVar *= 60.0;
                    break;
                case Units.Hours:
                    randomVar *= 3600.0;
                    break;
                case Units.Days:
                    randomVar *= 8640.0;
                    break;
            }
            if (randomVar < 0)
                randomVar = 0;
            return TimeSpan.FromSeconds(randomVar);
        }
    }

    /// <summary>
    /// A ConstantDoubleDistribution serves a constant value.
    /// </summary>
    public class ConstantDoubleDistribution : IDoubleDistribution {
        private double m_value;

        /// <summary>
        /// Creates a ConstantDoubleDistribution with a specific value;
        /// </summary>
        /// <param name="val">The (double) value that this distribution always serves up.</param>
        public ConstantDoubleDistribution(double val)
        {
            m_value = val;
        }

        /// <summary>
        /// Creates a ConstantDoubleDistribution with a specific value;
        /// </summary>
        /// <param name="model">the model of which this distribution is a part.</param>
        /// <param name="name">The name that this distribution goes by.</param>
        /// <param name="guid">The Guid of this distribution.</param>
        /// <param name="val">The (double) value that this distribution always serves up.</param>
        public ConstantDoubleDistribution(IModel model, string name, Guid guid, double val)
        {
            m_value = val;
        }

        #region IDoubleDistribution Members

        /// <summary>
        /// Returns the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            return m_value;
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_value;
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            // no effect.
        }

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form new ConstantDoubleDistribution().Initialize( ... );
        /// </summary>
        public ConstantDoubleDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.ConstantDoubleDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this ConstantDoubleDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this ConstantDoubleDistribution.</param>
        /// <param name="description">The description of this ConstantDoubleDistribution.</param>
        /// <param name="guid">The GUID of this ConstantDoubleDistribution.</param>
        /// <param name="val">The value that this ConstantDoubleDistribution always returns.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Value", RefType.Owned, typeof(double), "The constant value for this distribution.")]
			double val) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, val);
        }


        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_value = (double)p[0];
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model that owns this ConstantDoubleDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this ConstantDoubleDistribution.</param>
        /// <param name="description">The description of this ConstantDoubleDistribution.</param>
        /// <param name="guid">The GUID of this ConstantDoubleDistribution.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }
        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this Constant Double Distribution. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;
        private string m_description = "A Constant Double Distribution";
        /// <summary>
        /// A description of this Constant Double Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this Constant Double Distribution. Required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;

        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// For both theoretical and practical reasons, the normal distribution is 
    /// probably the most important distribution in statistics. For example, 
    /// <p></p>Many classical statistical tests are based on the assumption 
    /// that the data follow a normal distribution. This assumption should be
    /// tested before applying these tests. 
    /// <p></p>In modeling applications, such as linear and non-linear regression,
    /// the error term is often assumed to follow a normal distribution with fixed
    /// location and scale. 
    /// <p></p>The normal distribution is used to find significance levels in many
    /// hypothesis tests and confidence intervals. 
    /// <p></p> The mathematics for this distribution come from 
    /// http://home.online.no/~pjacklam/notes/invnorm/impl/misra/normsinv.html
    /// ...derived from http://www.netlib.org/specfun/erf
    /// </summary>
    public class NormalDistribution : IDoubleDistribution {

        #region Private Fields

        // Coefficients in rational approximations
        private static readonly double[] s_a = new double[]{-3.969683028665376e+01, 2.209460984245205e+02,
															 -2.759285104469687e+02, 1.383577518672690e+02,
															 -3.066479806614716e+01, 2.506628277459239e+00};
        private static readonly double[] s_b = new double[]{-5.447609879822406e+01, 1.615858368580409e+02,
															 -1.556989798598866e+02, 6.680131188771972e+01,
															 -1.328068155288572e+01};
        private static readonly double[] s_c = new double[]{-7.784894002430293e-03, -3.223964580411365e-01,
															 -2.400758277161838e+00, -2.549732539343734e+00,
															 4.374664141464968e+00, 2.938163982698783e+00};
        private static readonly double[] s_d = new double[]{7.784695709041462e-03, 3.224671290700398e-01,
															 2.445134137142996e+00, 3.754408661907416e+00};
        private static readonly double s_pLow = 0.02425;
        private static readonly double s_pHigh = 1.0 - s_pLow;

        private IRandomChannel m_random;
        private double m_mean;
        private double m_stdev;

        #endregion

        /// <summary>
        /// Creates a new instance of the <see cref="T:NormalDistribution"/> class.
        /// </summary>
        /// <param name="mean">The mean.</param>
        /// <param name="stdev">The stdev.</param>
        public NormalDistribution(double mean, double stdev)
            : this(null, "", Guid.Empty, mean, stdev) { }

        /// <summary>
        /// Creates a new instance of the <see cref="T:NormalDistribution"/> class.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The user-friendly name of this object. Typically not required to be unique in a pan-model context.</param>
        /// <param name="guid">The GUID of this object. Typically registered as this object's ModelObject key, and thus, required to be unique in a pan-model context.</param>
        /// <param name="mean">The mean.</param>
        /// <param name="stdev">The stdev.</param>
        public NormalDistribution(IModel model, string name, Guid guid, double mean, double stdev) {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
            m_mean = mean;
            m_stdev = stdev;
            // ReSharper disable once InvertIf
            if (Model != null) {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        #region IDistribution Members

        public double Mean { get { return m_mean; } set { m_mean = value; } }
        public double StandardDeviation { get { return m_stdev; } set { m_stdev = value; } }

        /// <summary>
        /// Returns the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public virtual double GetNext() {
            if (m_random == null) m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.

            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return GetValueWithCumulativeProbability(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="p">The probability.</param>
        /// <returns></returns>
        public virtual double GetValueWithCumulativeProbability(double p) {
            double retval, q;
            if (p < s_pLow) {
                // Rational approximation for lower region:
                q = Math.Sqrt(-2 * Math.Log(p, Math.E));
                retval = ( ( ( ( ( s_c[0] * q + s_c[1] ) * q + s_c[2] ) * q + s_c[3] ) * q + s_c[4] ) * q + s_c[5] ) / ( ( ( ( s_d[0] * q + s_d[1] ) * q + s_d[2] ) * q + s_d[3] ) * q + 1 );
            } else if (s_pHigh < p) {
                // Rational approximation for upper region:
                q = Math.Sqrt(-2 * Math.Log(1 - p, Math.E));
                retval = -( ( ( ( ( s_c[0] * q + s_c[1] ) * q + s_c[2] ) * q + s_c[3] ) * q + s_c[4] ) * q + s_c[5] ) / ( ( ( ( s_d[0] * q + s_d[1] ) * q + s_d[2] ) * q + s_d[3] ) * q + 1 );
            } else {
                // Rational approximation for central region:
                q = p - 0.5;
                double r = q * q;
                retval = ( ( ( ( ( s_a[0] * r + s_a[1] ) * r + s_a[2] ) * r + s_a[3] ) * r + s_a[4] ) * r + s_a[5] ) * q / ( ( ( ( ( s_b[0] * r + s_b[1] ) * r + s_b[2] ) * r + s_b[3] ) * r + s_b[4] ) * r + 1 );
            }
            //			return retval;
            //		}
            //		protected double ScaleAndOffSet(double baseValue){
            //			double retval = baseValue;
            retval *= m_stdev;
            retval += m_mean;
            return retval;
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form new NormalDistribution().Initialize( ... );
        /// </summary>
        public NormalDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.NormalDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this object and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this NormalDistribution.</param>
        /// <param name="description">The description of this NormalDistribution.</param>
        /// <param name="guid">The GUID of this NormalDistribution.</param>
        /// <param name="mean">The mean of this NormalDistribution.</param>
        /// <param name="stdev">The standard deviation of this NormalDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Mean", RefType.Owned, typeof(double), "Mean value for this distribution.")]
			double mean,
            [InitializerArg(1, "StdDev", RefType.Owned, typeof(double), "Standard Deviation for this distribution.")]
			double stdev) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, mean, stdev);
        }


        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            m_mean = (double)p[0];
            m_stdev = (double)p[1];
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }
        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this NormalDistribution. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;
        private string m_description = "A Normal Distribution";
        /// <summary>
        /// A description of this Normal Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this NormalDistribution. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this NormalDistribution, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// According to http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm, 
    /// the lognormal distribution is used extensively in reliability applications to 
    /// model failure times. The lognormal and Weibull distributions are probably the 
    /// most commonly used distributions in reliability applications.
    /// </summary>
    public class LognormalDistribution : NormalDistribution {

        /// <summary>
        /// Creates a new instance of the <see cref="T:LognormalDistribution"/> class.
        /// </summary>
        /// <param name="mean">The mean value of this LognormalDistribution.</param>
        /// <param name="stdev">The standard deviation of this LognormalDistribution.</param>
        public LognormalDistribution(double mean, double stdev)
            : base(null,"",Guid.Empty, mean, stdev) { }

        /// <summary>
        /// Creates a new instance of the <see cref="T:LognormalDistribution"/> class.
        /// </summary>
        /// <param name="model">The model that owns this LognormalDistribution.</param>
        /// <param name="name">The name of this LognormalDistribution.</param>
        /// <param name="guid">The GUID of this LognormalDistribution.</param>
        /// <param name="mean">The mean value of this LognormalDistribution.</param>
        /// <param name="stdev">The standard deviation of this LognormalDistribution.</param>
        public LognormalDistribution(IModel model, string name, Guid guid, double mean, double stdev)
            : base(model, name, guid, mean, stdev) { }

        #region IDistribution Members
        /// <summary>
        /// Returns the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public override double GetNext() {
            return Math.Exp(base.GetNext());
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public override double GetValueWithCumulativeProbability(double probability) {
            return Math.Exp(base.GetValueWithCumulativeProbability(probability));
        }

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new LognormalDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public LognormalDistribution()
        { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.NormalDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this object and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this LognormalDistribution.</param>
        /// <param name="description">The description of this LognormalDistribution.</param>
        /// <param name="guid">The GUID of this LognormalDistribution.</param>
        /// <param name="mean">The mean of this LognormalDistribution.</param>
        /// <param name="stdev">The standard deviation of this LognormalDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun, "_Initialize_LogNormal")]
        public new void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Mean", RefType.Owned, typeof(double), "Mean value for this distribution.")]
			double mean,
            [InitializerArg(1, "StdDev", RefType.Owned, typeof(double), "Standard Deviation for this distribution.")]
			double stdev) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, mean, stdev);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize_LogNormal(IModel model, object[] p) {
            _Initialize(model, p);
        }

        #endregion
    }

    /// <summary>
    /// A triangular distribution is a distribution defined on x in [a,b], where its Probability Density Function is
    /// <para/>
    /// P(x) = 2(x-a)/((b-a)(c-a)) for x on [a,c]
    /// <para/>
    /// P(x) = 2(b-x)/((b-a)(b-c)) for x on [c,b]
    /// </summary>
    public class TriangularDistribution : IDoubleDistribution {

        #region Private Fields

        private ICDF m_tcdf;
        private IRandomChannel m_random;

        #endregion

        /// <summary>
        /// Creates a new instance of the <see cref="T:TriangularDistribution"/> class.
        /// </summary>
        /// <param name="lowBound">The low bound.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="highBound">The high bound.</param>
        public TriangularDistribution(double lowBound, double mode, double highBound)
            : this(null, "", Guid.Empty, lowBound, mode, highBound)
        { }

        /// <summary>
        /// Creates a new instance of the <see cref="T:TriangularDistribution"/> class.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The user-friendly name of this object. Typically not required to be unique in a pan-model context.</param>
        /// <param name="guid">The GUID of this object. Typically registered as this object's ModelObject key, and thus, required to be unique in a pan-model context.</param>
        /// <param name="lowBound">The low bound.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="highBound">The high bound.</param>
        public TriangularDistribution(IModel model, string name, Guid guid, double lowBound, double mode, double highBound)
        {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
            m_tcdf = new TriangularCDF(lowBound, mode, highBound);
            if (Model != null)
            {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        #region IDistribution Members

        /// <summary>
        /// Returns the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return m_tcdf.GetVariate(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_tcdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new TriangularDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public TriangularDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.TriangularDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this TriangularDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this TriangularDistribution.</param>
        /// <param name="description">The description of this TriangularDistribution.</param>
        /// <param name="guid">The GUID of this TriangularDistribution.</param>
        /// <param name="lowBound">The low bound of the TriangularDistribution.</param>
        /// <param name="mean">The mean of the TriangularDistribution.</param>
        /// <param name="highBound">The high bound of the TriangularDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Low Bound", RefType.Owned, typeof(double), "The low boundary of this triangular distribution.")]
			double lowBound,
            [InitializerArg(1, "Mean Value", RefType.Owned, typeof(double), "The mean value of this triangular distribution.")]
			double mean,
            [InitializerArg(2, "High Bound", RefType.Owned, typeof(double), "The high boundary of this triangular distribution.")]
			double highBound) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, lowBound, mean, highBound);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double lowBound = (double)p[0];
            double mean = (double)p[1];
            double highBound = (double)p[2];
            m_tcdf = new TriangularCDF(lowBound, mean, highBound);
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }

        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this object. Typically not required to be unique.
        /// </summary>
        /// <value>The user-friendly name for this object.</value>
        public string Name => m_name;
        private string m_description = "A Triangular Distribution";
        /// <summary>
        /// A description of this Triangular Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this object. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// A Binomial distribution gives the discrete probability distribution P_p(n|N) of obtaining
    /// exactly n successes out of N Bernoulli trials (where the result of each Bernoulli trial
    /// is true with probability p and false with probability q==1-p).
    /// </summary>
    public class BinomialDistribution : IDoubleDistribution {

        #region Private Fields

        private IRandomChannel m_random;
        private ICDF m_bcdf;

        #endregion

        /// <summary>
        /// Create a binomial distribution.
        /// </summary>
        /// <param name="probability">The probability of success in any one Bernoulli trial.</param>
        /// <param name="numberOfOpps">The number of Bernoulli trials in the experiment.</param>
        public BinomialDistribution(double probability, int numberOfOpps)
            : this(null, "", Guid.Empty, probability, numberOfOpps)
        { }

        /// <summary>
        /// Create a binomial distribution.
        /// </summary>
        /// <param name="model">The model that owns this BinomialDistribution.</param>
        /// <param name="name">The name of this BinomialDistribution.</param>
        /// <param name="guid">The GUID of this BinomialDistribution.</param>
        /// <param name="probability">The probability of success in any one Bernoulli trial.</param>
        /// <param name="numberOfOpps">The number of Bernoulli trials in the experiment.</param>
        public BinomialDistribution(IModel model, string name, Guid guid, double probability, int numberOfOpps)
        {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
            m_bcdf = new BinomialCDF(probability, numberOfOpps);
            if (Model != null)
            {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        #region IDistribution Members

        /// <summary>
        /// Returns a value representing the number of successes experienced in a new experiment.
        /// </summary>
        /// <returns>The number of successes experienced in a new experiment. Returned as an integral value.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            // ReSharper disable once CompareOfFloatsByEqualityOperator
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return (int)Math.Round(m_bcdf.GetVariate(x), 0);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_bcdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new BinomialDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public BinomialDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.BinomialDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this BinomialDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this BinomialDistribution.</param>
        /// <param name="description">The description of this BinomialDistribution.</param>
        /// <param name="guid">The GUID of this BinomialDistribution.</param>
        /// <param name="probability">The probability of any one opportunity embodied by this BinomialDistribution.</param>
        /// <param name="numberOfOpps">The number of opportunities in a trial.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Probability", RefType.Owned, typeof(double), "The probability of success in any one opportunity.")]
			double probability,
            [InitializerArg(1, "Number Of Opportunities", RefType.Owned, typeof(int), "The number of opportunities in any given trial.")]
			int numberOfOpps) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, probability, numberOfOpps);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double probability = (double)p[0];
            int numberOfOpps = (int)p[1];
            m_bcdf = new BinomialCDF(probability, numberOfOpps);
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }

        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this object. Typically not required to be unique.
        /// </summary>
        /// <value>The user-friendly name for this object.</value>
        public string Name => m_name;
        private string m_description = "A Binomial Distribution";
        /// <summary>
        /// A description of this Binomial Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this Binomial Distribution. Typically required to be unique.
        /// </summary>
        /// <value>The Guid for this Binomial Distribution.</value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion

    }

    /// <summary>
    /// Produces an exponential distribution. The exponential distribution 
    /// is primarily used in reliability applications. The exponential 
    /// distribution is used to model data with a constant failure rate. 
    /// </summary>
    public class ExponentialDistribution : IDoubleDistribution {

        #region Private Fields

        private ExponentialCDF m_cdf;
        private IRandomChannel m_random;

        #endregion

        /// <summary>
        /// Creates an exponential distribution with a specified mean and beta.
        /// </summary>
        /// <param name="location">The mean, or location of the Exponential distribution.</param>
        /// <param name="scale">The scale, or beta of the Exponential distribution.</param>
        public ExponentialDistribution(double location, double scale)
            : this(null, "", Guid.Empty, location, scale) { }

        /// <summary>
        /// Creates an exponential distribution with a specified mean and beta.
        /// </summary>
        /// <param name="model">The model to which this exponential distribution belongs.</param>
        /// <param name="name">The name of this exponential distribution.</param>
        /// <param name="guid">The GUID of this exponential distribution.</param>
        /// <param name="location">The mean, or location of the Exponential distribution.</param>
        /// <param name="scale">The scale, or beta of the Exponential distribution.</param>
        public ExponentialDistribution(IModel model, string name, Guid guid, double location, double scale)
        {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
            m_cdf = new ExponentialCDF(location, scale, 500);
            if (Model != null)
            {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        #region IDistribution Members
        /// <summary>
        /// Serves up the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return m_cdf.GetVariate(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_cdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new ExponentialDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public ExponentialDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.ExponentialDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this ExponentialDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this ExponentialDistribution.</param>
        /// <param name="description">The description of this ExponentialDistribution.</param>
        /// <param name="guid">The GUID of this ExponentialDistribution.</param>
        /// <param name="location">The location (i.e. center) of the ExponentialDistribution.</param>
        /// <param name="scale">The scale (i.e. shape) of the ExponentialDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Location", RefType.Owned, typeof(double), "The mean of the Exponential distribution.")]
			double location,
            [InitializerArg(1, "Scale", RefType.Owned, typeof(double), "The beta of the Exponential distribution.")]
			double scale) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, location, scale);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double location = (double)p[0];
            double scale = (double)p[1];
            m_cdf = new ExponentialCDF(location, scale, 500);
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }
        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this object. Typically not required to be unique.
        /// </summary>
        /// <value>The user-friendly name for this object.</value>
        public string Name => m_name;
        private string m_description = "An Exponential Distribution";
        /// <summary>
        /// A description of this Exponential Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this object. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// Creates a Poisson Distribution. The Poisson distribution is a discrete
    /// distribution that is used to model the number of events occurring within
    /// a given time interval. 
    /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm
    /// </summary>
    public class PoissonDistribution : IDoubleDistribution {

        #region Private Fields

        private PoissonCDF m_cdf;
        private IRandomChannel m_random;

        #endregion

        /// <summary>
        /// Creates a Poisson Distribution with a specified mean.
        /// The upper range will be 4 times the mean.
        /// </summary>
        /// <param name="mean">The mean (lambda) of the distribution.</param>
        public PoissonDistribution(double mean)
            : this(null, "", Guid.Empty, mean) { }

        /// <summary>
        /// Creates a Poisson Distribution with a specified mean.
        /// The upper range will be 4 times the mean.
        /// </summary>
        /// <param name="model">The model that owns this Poisson Distribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this Poisson Distribution.</param>
        /// <param name="guid">The GUID of this Poisson Distribution.</param>
        /// <param name="mean">The mean (lambda) of the distribution.</param>
        public PoissonDistribution(IModel model, string name, Guid guid, double mean) {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();

            m_cdf = new PoissonCDF(mean, 4 * mean);
            if (Model != null) {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        #region IDistribution Members
        /// <summary>
        /// Serves up the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return m_cdf.GetVariate(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_cdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            Trace.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        //TODO: 1.) Make sure that what happens in any other ctors also happens in the Initialize method.
        //TODO: 2.) Replace all NAME? and DESCRIPTION? tags with the appropriate text.
        /// <summary>
        /// Use this for initialization of the form 'new PoissonDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public PoissonDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.PoissonDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this PoissonDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this PoissonDistribution.</param>
        /// <param name="description">The description of this PoissonDistribution.</param>
        /// <param name="guid">The GUID of this PoissonDistribution.</param>
        /// <param name="mean">The mean of the PoissonDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Mean", RefType.Owned, typeof(double), "The Mean Value of the Poisson Distribution.")]
			double mean) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, mean);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.

            double mean = (double)p[0];
            m_cdf = new PoissonCDF(mean, 10.0 * mean);

        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }

        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this object. Typically not required to be unique.
        /// </summary>
        /// <value>The user-friendly name for this object.</value>
        public string Name => m_name;
        private string m_description = "A Poisson Distribution";
        /// <summary>
        /// A description of this Poisson Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this object. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// Creates a Uniform Distribution with a specified minimum and maximum. 
    /// The uniform distribution defines equal probability over a given range
    /// for a continuous distribution. For this reason, it is important as a
    /// reference distribution. <p></p>
    /// One of the most important applications of the uniform distribution
    /// is in the generation of random numbers. That is, almost all random
    /// number generators generate random numbers on the (0,1) interval. For
    /// other distributions, some transformation is applied to the uniform
    /// random numbers. 
    /// </summary>
    public class UniformDistribution : IDoubleDistribution {

        #region Private Fields

        private UniformCDF m_cdf;
        private IRandomChannel m_random;
        private double m_minimum;
        private double m_maximum;

        #endregion

        /// <summary>
        /// Creates a Uniform Distribution with a specified minimum and maximum.
        /// </summary>
        /// <param name="minimum">The minimum of the distribution.</param>
        /// <param name="maximum">The maximum of the distribution.</param>
        public UniformDistribution(double minimum, double maximum)
            : this(null, "", Guid.Empty, minimum, maximum) {
        }

        /// <summary>
        /// Creates a Uniform Distribution with a specified minimum and maximum.
        /// </summary>
        /// <param name="model">The model that owns this Uniform Distribution.</param>
        /// <param name="name">The name of this Uniform Distribution.</param>
        /// <param name="guid">The GUID of this Uniform Distribution.</param>
        /// <param name="minimum">The minimum of the distribution.</param>
        /// <param name="maximum">The maximum of the distribution.</param>
        public UniformDistribution(IModel model, string name, Guid guid, double minimum, double maximum)
        {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_minimum = minimum;
            m_maximum = maximum;

            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();

            m_cdf = new UniformCDF(m_minimum, m_maximum);
            if (Model != null)
            {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        public double Minimum => m_minimum;

        public double Maximum => m_maximum;

        public void SetBounds(double minimum, double maximum) {
            m_minimum = minimum;
            m_maximum = maximum;
            m_cdf = new UniformCDF(m_minimum, m_maximum);
        }

        #region IDistribution Members
        /// <summary>
        /// Serves up the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return m_cdf.GetVariate(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_cdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new UniformDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public UniformDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.UniformDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this UniformDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this UniformDistribution.</param>
        /// <param name="description">The description of this UniformDistribution.</param>
        /// <param name="guid">The GUID of this UniformDistribution.</param>
        /// <param name="minimum">The minimum value in this UniformDistribution.</param>
        /// <param name="maximum">The maximum value in this UniformDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Minimum", RefType.Owned, typeof(double), "The minimum of the distribution.")]
			double minimum,
            [InitializerArg(1, "Maximum", RefType.Owned, typeof(double), "The maximum of the distribution.")]
			double maximum) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            SetBounds(minimum, maximum);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, minimum, maximum);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double minimum = (double)p[0];
            double maximum = (double)p[1];
            SetBounds(minimum, maximum);
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }

        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this Uniform Distribution. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;
        private string m_description = "A Uniform Distribution";
        /// <summary>
        /// A description of this Uniform Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this Uniform Distribution. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this Uniform Distribution, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// The Cauchy distribution is important
    /// as an example of a pathological case. Cauchy distributions look similar
    /// to a normal distribution. However, they have much heavier tails. When
    /// studying hypothesis tests that assume normality, seeing how the tests
    /// perform on data from a Cauchy distribution is a good indicator of how
    /// sensitive the tests are to heavy-tail departures from normality.
    /// Likewise, it is a good check for robust techniques that are designed to
    /// work well under a wide variety of distributional assumptions. 
    /// </summary>
    public class CauchyDistribution : IDoubleDistribution {

        #region Private Fields

        private CauchyCDF m_cdf;
        private IRandomChannel m_random;

        #endregion

        /// <summary>
        /// Creates a Cauchy Distribution with a specified location and shape.
        /// </summary>
        /// <param name="location">The location (center) of the distribution.</param>
        /// <param name="shape">The shape (extent) of the distribution.</param>
        public CauchyDistribution(double location, double shape)
            : this(null, "", Guid.Empty, location, shape) { }

        /// <summary>
        /// Creates a Cauchy Distribution with a specified location and shape.
        /// </summary>
        /// <param name="model">The model that owns this Cauchy Distribution.</param>
        /// <param name="name">The name of this Cauchy Distribution.</param>
        /// <param name="guid">The GUID of this Cauchy Distribution.</param>
        /// <param name="location">The location (center) of the distribution.</param>
        /// <param name="shape">The shape (extent) of the distribution.</param>
        public CauchyDistribution(IModel model, string name, Guid guid, double location, double shape)
        {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
            m_cdf = new CauchyCDF(location, shape);
            if (Model != null)
            {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }
        }

        #region IDistribution Members
        /// <summary>
        /// Serves up the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return m_cdf.GetVariate(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_cdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        //TODO: 1.) Make sure that what happens in any other ctors also happens in the Initialize method.
        //TODO: 2.) Replace all NAME? and DESCRIPTION? tags with the appropriate text.
        /// <summary>
        /// Use this for initialization of the form 'new CauchyDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public CauchyDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.CauchyDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this CauchyDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this CauchyDistribution.</param>
        /// <param name="description">The description of this CauchyDistribution.</param>
        /// <param name="guid">The GUID of this CauchyDistribution.</param>
        /// <param name="location">The location of this CauchyDistribution.</param>
        /// <param name="shape">The shape of this CauchyDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Location", RefType.Owned, typeof(double), "The location (center) of the distribution.")]
			double location,
            [InitializerArg(1, "Shape", RefType.Owned, typeof(double), "The shape (extent) of the distribution.")]
			double shape) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, location, shape);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double location = (double)p[0];
            double shape = (double)p[1];
            m_cdf = new CauchyCDF(location, shape);
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }

        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this Cauchy Distribution. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;
        private string m_description = "A Cauchy Distribution";
        /// <summary>
        /// A description of this Cauchy Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this Cauchy Distribution. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this object, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// The Weibull distribution is used extensively in reliability applications to model failure times. 
    /// </summary>
    public class WeibullDistribution : IDoubleDistribution {

        #region Private Fields

        //private WeibullCDF m_cdf = null;
        private IRandomChannel m_random;
        private double m_location;
        private double m_scale;
        private double m_invGamma;

        #endregion

        /// <summary>
        /// The Weibull distribution is used extensively in reliability applications to model failure times.
        /// </summary>
        /// <param name="shape">The shape parameter. Must be &gt; 0. &lt; 1 looks like an L, ~1 looks like a '/', and &gt; 1 looks like a '/\_'</param>
        /// <param name="location">The location parameter. Where the distribution is, on the X axis.</param>
        /// <param name="scale">The scale parameter.</param>
        public WeibullDistribution(double shape, double location, double scale)
            : this(null, "", Guid.Empty, shape, location, scale) { }

        /// <summary>
        /// The Weibull distribution is used extensively in reliability applications to model failure times.
        /// </summary>
        /// <param name="model">The model to which this Weibull Distribution belongs.</param>
        /// <param name="name">The name of this Weibull Distribution.</param>
        /// <param name="guid">The GUID of this Weibull Distribution.</param>
        /// <param name="shape">The shape parameter. Must be &gt; 0. &lt; 1 looks like an L, ~1 looks like a '/', and &gt; 1 looks like a '/\_'</param>
        /// <param name="location">The location parameter. Where the distribution is, on the X axis.</param>
        /// <param name="scale">The scale parameter.</param>
        public WeibullDistribution(IModel model, string name, Guid guid, double shape, double location, double scale) {
            if (shape <= 0 || scale <= 0) {
                throw new ArgumentException("Shape and scale parameters in a Weibull Distribution must be greater than zero.");
            }
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();

            m_location = location;
            m_scale = scale;
            //m_cdf = new WeibullCDF(gamma,100);
            m_invGamma = 1.0 / shape;
            if (Model != null) {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }

        }

        #region IDistribution Members
        /// <summary>
        /// Serves up the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            //return (m_location +(m_scale * m_cdf.GetVariate(m_random.NextDouble())));
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return GetValueWithCumulativeProbability(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            double x = Math.Pow(-Math.Log(1 - probability, Math.E), m_invGamma);
            return ( m_location + ( m_scale * x ) );
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new WeibullDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public WeibullDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.WeibullDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this WeibullDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this WeibullDistribution.</param>
        /// <param name="description">The description of this WeibullDistribution.</param>
        /// <param name="guid">The GUID of this WeibullDistribution.</param>
        /// <param name="shape">The shape of this WeibullDistribution.</param>
        /// <param name="location">The location of this WeibullDistribution.</param>
        /// <param name="scale">The scale of this WeibullDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "Shape", RefType.Owned, typeof(double), "The shape parameter. Must be > 0. <1 looks like an L, ~1 looks like a '/', and > 1 looks like a '/\\_'")]
			double shape,
            [InitializerArg(1, "Location", RefType.Owned, typeof(double), "The location parameter. Where the distribution is, on the X axis.")]
			double location,
            [InitializerArg(2, "Scale", RefType.Owned, typeof(double), "The scale parameter - the extent of the distribution")]
			double scale) {

            if (shape <= 0 || scale <= 0) {
                throw new ArgumentException("Shape parameter in a Weibull Distribution must be greater than zero.");
            }

            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, shape, location, scale);
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double shape = (double)p[0];
            m_location = (double)p[1];
            m_scale = (double)p[2];

            //m_cdf = new WeibullCDF(gamma,100);
            m_invGamma = 1.0 / shape;

        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }

        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this Weibull Distribution. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;
        private string m_description = "A Weibull Distribution";
        /// <summary>
        /// A description of this Weibull Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this Weibull Distribution. Typically required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this Weibull Distribution, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// An Empirical distribution is a distribution that is formed from a Probability Density Function (PDF) that
    /// is provided by an external entity. The PDF is provided as a pair of x-value and y-value arrays. Like-indexed
    /// elements in these arrays are assumed to correspond to each other to form an (x,y) value that is a point on
    /// the PDF being described. Additionally, an Interpolator may be specified to smooth the otherwise piecewise
    /// linear PDF "curve."
    /// </summary>
    public class EmpiricalDistribution : IDoubleDistribution {

        #region Private Fields
        private EmpiricalCDF m_cdf;
        private IRandomChannel m_random;
        #endregion

        /// <summary>
        /// An empirical distribution creates a distribution whose CDF looks like an empirically-declared curve.
        /// </summary>
        /// <param name="xVals">The X values that form the empirical data inflection points.</param>
        /// <param name="yVals">The Y values that form the empirical data inflection points.</param>
        /// <param name="idi">An implementer of IDoubleInterpolator that this distribution will use to ascertain values between provided inflection points.</param>
        public EmpiricalDistribution(double[] xVals, double[] yVals, IDoubleInterpolator idi)
            : this(null, "", Guid.Empty, xVals, yVals) { }

        /// <summary>
        /// An empirical distribution creates a distribution whose CDF looks like an empirically-declared curve.
        /// </summary>
        /// <param name="model">The model in which this distribution participates.</param>
        /// <param name="name">The name assigned to this distribution.</param>
        /// <param name="guid">The guid that identifies this distribution.</param>
        /// <param name="xVals">The X values that form the empirical data inflection points.</param>
        /// <param name="yVals">The Y values that form the empirical data inflection points.</param>
        /// <param name="idi">An implementer of IDoubleInterpolator that this distribution will use to ascertain values between provided inflection points.</param>
        public EmpiricalDistribution(IModel model, string name, Guid guid, double[] xVals, double[] yVals, IDoubleInterpolator idi)
        {
            m_model = model;
            m_name = name;
            m_guid = guid;
            m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
            m_cdf = new EmpiricalCDF(xVals, yVals, idi);
            if (Model != null)
            {
                Model.ModelObjects.Remove(guid);
                Model.ModelObjects.Add(guid, this);
            }

        }

        /// <summary>
        /// An empirical distribution creates a distribution whose CDF looks like an empirically-declared curve.
        /// </summary>
        /// <param name="model">The model in which this distribution participates.</param>
        /// <param name="name">The name assigned to this distribution.</param>
        /// <param name="guid">The guid that identifies this distribution.</param>
        /// <param name="xVals">The X values that form the empirical data inflection points.</param>
        /// <param name="yVals">The Y values that form the empirical data inflection points.</param>
        public EmpiricalDistribution(IModel model, string name, Guid guid, double[] xVals, double[] yVals)
            : this(model, name, guid, xVals, yVals, new LinearDoubleInterpolator()) { }

        #region IDoubleDistribution Members
        /// <summary>
        /// Returns the next double in the distribution.
        /// </summary>
        /// <returns>The next double in the distribution.</returns>
        public double GetNext() {
            if (m_random == null)
                m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
            double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
            return GetValueWithCumulativeProbability(x);
        }

        /// <summary>
        /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
        /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
        /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
        /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
        /// </summary>
        /// <param name="probability">The probability.</param>
        /// <returns></returns>
        public double GetValueWithCumulativeProbability(double probability) {
            return m_cdf.GetVariate(probability);
        }

        /// <summary>
        /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
        /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
        /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
        /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
        /// </summary>
        /// <param name="low">The low bound (inclusive).</param>
        /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
        public void SetCDFInterval(double low, double high) {
            System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
            m_low = low;
            m_high = high;
            m_constrained = ( m_low != 0.0 && m_high != 1.0 );
        }

        private bool m_constrained;
        private double m_low;
        private double m_high = 1.0;

        #endregion

        #region Initialization
        /// <summary>
        /// Use this for initialization of the form 'new EmpiricalDistribution().Initialize( ... );'
        /// Note that this mechanism relies on the whole model performing initialization.
        /// </summary>
        public EmpiricalDistribution() { }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.Highpoint.Sage.Mathematics.EmpiricalDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this EmpiricalDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this EmpiricalDistribution.</param>
        /// <param name="description">The description of this EmpiricalDistribution.</param>
        /// <param name="guid">The GUID of this EmpiricalDistribution.</param>
        /// <param name="xVals">The x values that make up the Cumulative Density Function of this EmpiricalDistribution.</param>
        /// <param name="yVals">The y values that make up the Cumulative Density Function of this EmpiricalDistribution.</param>
        /// <param name="interpolatorType">The type of the interpolator that this EmpiricalDistribution should use.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "XValues", RefType.Owned, typeof(double[]), "The X values that form the empirical data inflection points.")]
			double[] xVals,
            [InitializerArg(1, "YValues", RefType.Owned, typeof(double[]), "The Y values that form the empirical data inflection points.")]
			double[] yVals,
            [InitializerArg(2, "InterpolatorType", RefType.Watched, typeof(Type), "A type that implements IDoubleInterpolator that this distribution will use to ascertain values between known inflection points.")]
			Type interpolatorType) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            if (!typeof(IDoubleInterpolator).IsAssignableFrom(interpolatorType)) {
                throw new ArgumentException("Argument 'interpolatorType' must implement IDoubleInterpolator.");
            }

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, xVals, yVals, interpolatorType);
        }

        /// <summary>
        /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.EmpiricalDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
        /// </summary>
        /// <param name="model">The model that owns this EmpiricalDistribution and in whose context the initialization is being performed.</param>
        /// <param name="name">The name of this EmpiricalDistribution.</param>
        /// <param name="description">The description of this EmpiricalDistribution.</param>
        /// <param name="guid">The GUID of this EmpiricalDistribution.</param>
        /// <param name="xVals">The x values that make up the Cumulative Density Function of this EmpiricalDistribution.</param>
        /// <param name="yVals">The y values that make up the Cumulative Density Function of this EmpiricalDistribution.</param>
        [Initializer(InitializerAttribute.InitializationType.PreRun)]
        public void Initialize(IModel model, string name, string description, Guid guid,
            [InitializerArg(0, "XValues", RefType.Owned, typeof(double[]), "The X values that form the empirical data inflection points.")]
			double[] xVals,
            [InitializerArg(1, "YValues", RefType.Owned, typeof(double[]), "The Y values that form the empirical data inflection points.")]
			double[] yVals) {
            InitializeIdentity(model, name, description, guid);
            IMOHelper.RegisterWithModel(this);

            model.GetService<InitializationManager>().AddInitializationTask(_Initialize, xVals, yVals, typeof(LinearDoubleInterpolator));
        }

        /// <summary>
        /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
        /// </summary>
        /// <param name="model">The model into which this object is to be initialized.</param>
        /// <param name="p">The parameters that will be used to initialize this object.</param>
        public void _Initialize(IModel model, object[] p) {
            m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
            double[] xVals = (double[])m_model.ModelObjects[p[0]];
            double[] yVals = (double[])m_model.ModelObjects[p[1]];

            Type idiType = (Type)m_model.ModelObjects[p[2]];
            ConstructorInfo ci = idiType.GetConstructor(new Type[] { });
            if (ci != null)
            {
                IDoubleInterpolator idi = (IDoubleInterpolator)ci.Invoke(new object[] { });

                m_cdf = new EmpiricalCDF(xVals, yVals, idi);
            }
        }

        /// <summary>
        /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
        /// </summary>
        /// <param name="model">The model in which this object runs.</param>
        /// <param name="name">The object's name.</param>
        /// <param name="description">The object's description.</param>
        /// <param name="guid">The object's GUID.</param>
        public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
            IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
        }
        #endregion

        #region IModelObject Members
        private string m_name;
        /// <summary>
        /// The user-friendly name for this Empirical Distribution. Typically not required to be unique.
        /// </summary>
        /// <value></value>
        public string Name => m_name;
        private string m_description = "An Empirical Distribution";
        /// <summary>
        /// A description of this Empirical Distribution.
        /// </summary>
        public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
        /// <summary>
        /// The Guid for this Empirical Distribution. Required to be unique.
        /// </summary>
        /// <value></value>
        public Guid Guid => m_guid;
        private IModel m_model;
        /// <summary>
        /// The model that owns this Empirical Distribution, or from which this object gets time, etc. data.
        /// </summary>
        /// <value>The model.</value>
        public IModel Model => m_model;
        #endregion
    }

    /// <summary>
    /// An Empirical distribution is a distribution that is formed from a Probability Density Function (PDF) that
    /// is provided by an external entity. The PDF is provided as a pair of x-value and y-value arrays. Like-indexed
    /// elements in these arrays are assumed to correspond to each other to form an (x,y) value that is a point on
    /// the PDF being described. Additionally, an Interpolator may be specified to smooth the otherwise piecewise
    /// linear PDF "curve."
    /// </summary>
    public class UniversalDistribution : IDoubleDistribution {

      #region Private Fields
      private ICDF m_cdf;
      private IRandomChannel m_random;
      #endregion

      /// <summary>
      /// A universal distribution relies on the caller to have implemented an arbitrary Cumulative Density Function.
      /// </summary>
      /// <param name="cumulativeDensityFunction">An implementer of ICDF that this distribution will use to ascertain values.</param>
      public UniversalDistribution(ICDF cumulativeDensityFunction)
          : this(null, "", Guid.Empty, cumulativeDensityFunction) { }

      /// <summary>
      /// A universal distribution relies on the caller to have implemented an arbitrary Cumulative Density Function.
      /// </summary>
      /// <param name="model">The model in which this distribution participates.</param>
      /// <param name="name">The name assigned to this distribution.</param>
      /// <param name="guid">The guid that identifies this distribution.</param>
      /// <param name="cumulativeDensityFunction">An implementer of ICDF that this distribution will use to ascertain values.</param>
      public UniversalDistribution(IModel model, string name, Guid guid, ICDF cumulativeDensityFunction)
      {
          InitializeIdentity(model, name, null, guid);
          m_random = (Model == null ? GlobalRandomServer.Instance : Model.RandomServer).GetRandomChannel();
          m_cdf = cumulativeDensityFunction;
          IMOHelper.RegisterWithModel(this);
      }

      #region IDoubleDistribution Members
      /// <summary>
      /// Returns the next double in the distribution.
      /// </summary>
      /// <returns>The next double in the distribution.</returns>
      public double GetNext() {
        if (m_random == null){
          m_random = m_model.RandomServer.GetRandomChannel(); // If _Initialize() was called, this is necessary.
        }
        double x = m_constrained ? ( m_low == m_high ? m_low : m_random.NextDouble(m_low, m_high) ) : m_random.NextDouble();
        return GetValueWithCumulativeProbability(x);
      }

      /// <summary>
      /// Gets the Y (distribution) value with the specified X (cumulative probability) value. For example,
      /// if the caller wishes to know what Y value will, with 90% certainty, always be greater than or equal
      /// to a value returned from the distribution, he would ask for GetValueWithCumulativeProbability(0.90);
      /// <para>Note: The median value of the distribution will be GetValueWithCumulativeProbability(0.50);</para>
      /// </summary>
      /// <param name="probability">The probability.</param>
      /// <returns></returns>
      public double GetValueWithCumulativeProbability(double probability) {
          return m_cdf.GetVariate(probability);
      }

      /// <summary>
      /// Sets the interval on which the CDF is queried for X. The RNG internally generates a number 'x' on (0..1), and CDF(x) is the output
      /// random number on the distribution. For the purpose of generating a schedule, running monte-carlo simulations
      /// of schedules and other related tasks, we may want to generate randoms on just a portion of that CDF, say
      /// instead of (0..1), perhaps (0..0.95), or if we want the mean value, we would use an interval of (0.5,0.5).
      /// </summary>
      /// <param name="low">The low bound (inclusive).</param>
      /// <param name="high">The high bound (exclusive, unless low and high are equal).</param>
      public void SetCDFInterval(double low, double high) {
          System.Diagnostics.Debug.Assert(low >= 0 && high <= 1 && low <= high);
          m_low = low;
          m_high = high;
          m_constrained = ( m_low != 0.0 && m_high != 1.0 );
      }

      private bool m_constrained;
      private double m_low;
      private double m_high = 1.0;

      #endregion

      #region Initialization
      /// <summary>
      /// Use this for initialization of the form 'new UniversalDistribution().Initialize( ... );'
      /// Note that this mechanism relies on the whole model performing initialization.
      /// </summary>
      public UniversalDistribution() { }

      /// <summary>
      /// Initializes this <see cref="T:Highpoint.Sage.Mathematics.Highpoint.Sage.Mathematics.EmpiricalDistribution"/> in the context of the specified model. Requires execution against the Sage intialization protocol. Guids specified are those of other objects in the model which this object must interact during initialization.
      /// </summary>
      /// <param name="model">The model that owns this UniversalDistribution and in whose context the initialization is being performed.</param>
      /// <param name="name">The name of this UniversalDistribution.</param>
      /// <param name="description">The description of this UniversalDistribution.</param>
      /// <param name="guid">The GUID of this UniversalDistribution.</param>
      /// <param name="cdfGuid">The Cumulative Density Function of this UniversalDistribution.</param>
      [Initializer(InitializerAttribute.InitializationType.PreRun)]
      public void Initialize(IModel model, string name, string description, Guid guid,
          [InitializerArg(0, "CumulativeDensityFunction", RefType.Owned, typeof(ICDF), "The Cumulative Density Function that will drive this Universal Distribution.")]
      Guid cdfGuid) {
        InitializeIdentity(model, name, description, guid);
        IMOHelper.RegisterWithModel(this);

        model.GetService<InitializationManager>().AddInitializationTask(_Initialize, cdfGuid);
      }

      /// <summary>
      /// Used by the <see cref="T:Highpoint.Sage.SimCore.InitializationManager"/> in the sequenced execution of an initialization protocol.
      /// </summary>
      /// <param name="model">The model into which this object is to be initialized.</param>
      /// <param name="p">The parameters that will be used to initialize this object.</param>
      public void _Initialize(IModel model, object[] p) {
        m_random = null; // Allows the random channel to be obtained at run time, after model has properly initialized it.
        m_cdf = (ICDF)m_model.ModelObjects[p[0]];

      }

      /// <summary>
      /// Performs the part of object initialization that pertains to the fields associated with this object's being an implementer of IModelObject.
      /// </summary>
      /// <param name="model">The model in which this object runs.</param>
      /// <param name="name">The object's name.</param>
      /// <param name="description">The object's description.</param>
      /// <param name="guid">The object's GUID.</param>
      public void InitializeIdentity(IModel model, string name, string description, Guid guid) {
        IMOHelper.Initialize(ref m_model, model, ref m_name, name, ref m_description, description, ref m_guid, guid);
      }
      #endregion

      #region IModelObject Members
      private string m_name;
      /// <summary>
      /// The user-friendly name for this Empirical Distribution. Typically not required to be unique.
      /// </summary>
      /// <value></value>
      public string Name => m_name;
      private string m_description = "An Empirical Distribution";
      /// <summary>
      /// A description of this Empirical Distribution.
      /// </summary>
      public string Description => m_description ?? m_name;

        private Guid m_guid = Guid.Empty;
      /// <summary>
      /// The Guid for this Empirical Distribution. Required to be unique.
      /// </summary>
      /// <value></value>
      public Guid Guid => m_guid;
      private IModel m_model;
      /// <summary>
      /// The model that owns this Empirical Distribution, or from which this object gets time, etc. data.
      /// </summary>
      /// <value>The model.</value>
      public IModel Model => m_model;
      #endregion
  }


    #region >>> Cumulative Density Functions <<<

    /// <summary>
    /// With the value of 'linear' in the Y-value range of (0.0-1.0], this
    /// will return the X-value variate from the implementing CDF. 
    /// </summary>
    public interface ICDF {
        /// <summary>
        /// Returns the X-value variate from the implementing CDF that corresponds to the value of 'linear'.
        /// </summary>
        /// <param name="linear">A double in the range of (0.0-1.0].</param>
        /// <returns></returns>
        double GetVariate(double linear);
    }

    /// <summary>
    /// Implements a linear CDF with an X-range of (0.0-1.0]
    /// </summary>
    class Linear : ICDF {
        /// <summary>
        /// Returns the X-value variate from a Linear CDF that corresponds to the value of 'linear'.
        /// </summary>
        /// <param name="linear">A double in the range of (0.0-1.0].</param>
        /// <returns></returns>
        public double GetVariate(double linear) { return linear; }
    }

    /// <summary>
    /// Implements an exponential CDF mapped across a table with a specified number of entries or bins.
    /// Y values will range from (0.0-1.0], and the x-values at the given Y value will be stored in the
    /// corresponding bin.
    /// </summary>
    public class ExponentialCDF : ICDF {
        readonly double[] m_cdfX;
        readonly int m_nBins;
        readonly double m_location;
        public ExponentialCDF(double location, double scale, int nBins) {
            m_location = location;
            m_nBins = nBins;
            double delta = 1.0 / m_nBins;
            m_cdfX = new double[nBins + 1];
            for (int i = 1 ; i <= nBins ; i++) {
                double y = i * delta;
                if (y == 1)
                    y -= ( delta / 10.0 ); // Calculation with Y = 1 blows up. This distorts the top .2% of the histogram. 
                m_cdfX[i] = ( -scale * Math.Log(1 - y) );
            }
        }

        #region Implementation of ICDF
        public double GetVariate(double linear) {
            // linear is (0..1] - should assert that.

            double scala = linear * m_nBins;
            int lowerBin = (int)scala;
            double fraction = scala - lowerBin;
            double lowerX = m_cdfX[lowerBin];
            if (fraction == 0.0)
                return m_location + lowerX;
            double upperX = m_cdfX[lowerBin + 1];
            double retval = lowerX + ( fraction * ( upperX - lowerX ) );

            return m_location + retval;
        }
        #endregion
    }

    /// <summary>
    /// Implements an empirical CDF. The xValues passed in will be in the interval of [0.0,1.0), and
    /// the yValues passed in will be empirically-determined data points.
    /// </summary>
    class EmpiricalCDF : ICDF {
        private readonly SmallDoubleInterpolable m_empirical;

        /// <summary>
        /// Creates an empirical, table-driven CDF from a histogram containing 'n' bins (where n > 1) with low and high bounds,
        /// and a count of instances (column height, in effect) in each bin. For example, with binBounds being a double[]
        /// with values {3.0, 5.0, 6.0, 7.0}, and heights being a double[] with values {10.0, 30.0, 20.0}, and a linear
        /// double interpolator, the empirical CDF will produce values evenly spaced from 3 to 5 1/6th of the time, values
        /// evenly spaced from 5 to 6 half the time, and values evenly spaced from 6 to 7 one third of the time.
        /// <p></p>This form of the constructor defaults to a linear interpolation.
        /// </summary>
        /// <param name="binBounds">An array of 'n+1' doubles in ascending order denoting the boundaries of the bins of the histogram.</param>
        /// <param name="heights">An array of 'n' doubles denoting the height of the bins.</param>
        /// <returns>An empirical CDF that returns the same distribution as represented in the histogram.</returns>
        public EmpiricalCDF(double[] binBounds, double[] heights) : this(binBounds, heights, new LinearDoubleInterpolator()) { }

        /// <summary>
        /// Creates an empirical, table-driven CDF from a histogram containing 'n' bins (where n > 1) with low and high bounds,
        /// and a count of instances (column height, in effect) in each bin. For example, with binBounds being a double[]
        /// with values {3.0, 5.0, 6.0, 7.0}, and heights being a double[] with values {10.0, 30.0, 20.0}, and a linear
        /// double interpolator, the empirical CDF will produce values evenly spaced from 3 to 5 1/6th of the time, values
        /// evenly spaced from 5 to 6 half the time, and values evenly spaced from 6 to 7 one third of the time.
        /// </summary>
        /// <param name="binBounds">An array of 'n+1' doubles in ascending order denoting the boundaries of the bins of the histogram.</param>
        /// <param name="heights">An array of 'n' doubles denoting the height of the bins.</param>
        /// <param name="idi">A doubleInterpolator.</param>
        /// <returns>An empirical CDF that returns the same distribution as represented in the histogram.</returns>
        public EmpiricalCDF(double[] binBounds, double[] heights, IDoubleInterpolator idi) {
            if (binBounds.Length != heights.Length + 1)
                throw new ApplicationException("Trying to create an empirical CDF from a histogram with other than 'n-1' height entries for 'n' interval entries.");
            // First, compute the total area under the histogram.
            double area = 0.0;
            int i = 0;
            for ( ; i < heights.Length ; i++) {
                if (binBounds[i + 1] <= binBounds[i])
                    throw new ApplicationException("Trying to create an empirical CDF from a histogram with unsorted bins.");
                if (heights[i] < 0)
                    throw new ApplicationException("Trying to create an empirical CDF from a histogram with a negative entry. All heights must be zero or positive.");
                area += ( ( binBounds[i + 1] - binBounds[i] ) * heights[i] );
            }
            if (area == 0.0)
                throw new ApplicationException("Trying to create an empirical CDF from a histogram that has no entries. At least one height entry must be positive and non-zero.");

            double[] xVals = new double[binBounds.Length];
            double[] yVals = new double[binBounds.Length];

            yVals[0] = binBounds[0];
            xVals[0] = 0.0;
            for (i = 1 ; i < heights.Length ; i++) {
                yVals[i] = binBounds[i];
                xVals[i] = xVals[i - 1] + ( ( ( yVals[i] - yVals[i - 1] ) * heights[i - 1] ) / area );
            }
            yVals[i] = binBounds[i];
            xVals[i] = 1.0;
            m_empirical = new SmallDoubleInterpolable(xVals, yVals, idi);
        }

        #region Implementation of ICDF
        public double GetVariate(double linear) {
            return m_empirical.GetYValue(linear);
        }
        #endregion

    }

    class PoissonCDF : ICDF {
        private  SmallDoubleInterpolable m_sdi;

        // ReSharper disable once InconsistentNaming
        public PoissonCDF(double lambda, double outerLimit) {
            if (!LookupTableInitialization(lambda, outerLimit)) ComputationalInitialization(lambda, outerLimit);
        }

        private bool LookupTableInitialization(double lambda, double outerLimit)
        {
            List<double> xValues = PoissonCDFLookupTable.ForLambda(lambda);
            if (xValues == null) return false;
            List<double> yValues = new List<double>();
            double d = -1;
            xValues.ForEach(nul=>yValues.Add(++d));
            m_sdi = new SmallDoubleInterpolable(xValues.ToArray(), yValues.ToArray());
            return true;
        }

        private bool ComputationalInitialization(double _lambda, double outerLimit)
        {
            double lambda = _lambda;
            int intOuterLimit = (int)Math.Ceiling(outerLimit);
            InitFactorials(intOuterLimit + 1);
            double[] x = new double[intOuterLimit + 1];
            double[] y = new double[intOuterLimit + 1];
            double runningSum = 0;
            double eToThePowerOfLambda = Math.Exp(-lambda);
            int i = 0;
            x[i] = 0.0;
            y[i] = i;
            for (i = 1; i < intOuterLimit; i++)
            {
                runningSum += eToThePowerOfLambda * Math.Pow(lambda, i) / Factorial(i);
                x[i] = runningSum;
                y[i] = i;
            }
            x[i] = 1.0; // establish upper boundary at 1.0 probability.
            y[i] = y[i - 1] + ((y[i - 1] - y[i - 2])); // The last bin ramps down at half the rate of the bin before it.
            IDoubleInterpolator idi = new LinearDoubleInterpolator();
            idi.SetData(x, y);
            m_sdi = new SmallDoubleInterpolable(intOuterLimit, idi);
            return true;
        }

        #region ICDF Members

        public double GetVariate(double linear) {
            return Math.Round(m_sdi.GetYValue(linear)+0.5); // Find the nearest integer value.
        }

        #endregion

        private double[] m_factorials;
        private void InitFactorials(int max) {
            m_factorials = new double[max + 1];
            double f = 1;
            m_factorials[0] = 1;
            for (int i = 1 ; i <= max ; i++) {
                f *= i;
                m_factorials[i] = f;
            }
        }

        private double Factorial(int x) {
            return m_factorials[x];
        }


    }

    class UniformCDF : ICDF {
        readonly double m_min;
        readonly double m_dx;
        public UniformCDF(double min, double max) {
            m_min = min;
            m_dx = ( max - min );
        }

        #region ICDF Members

        public double GetVariate(double linear) {
            return m_min + ( m_dx * linear );
        }

        #endregion

    }

    class CauchyCDF : ICDF {
        readonly double m_location;
        readonly double m_shape;
        public CauchyCDF(double location, double shape) {
            m_location = location;
            m_shape = shape;
        }

        #region ICDF Members

        public double GetVariate(double linear) {
            return m_location + ( m_shape * ( Math.Tan(( linear - 0.5 ) * Math.PI) ) );
        }

        #endregion

    }

    #region Unneeded Gaussian CDF. All commented out.
    /*
	class GaussianCDF : ICDF {
		double[] m_cdfX;
		double m_delta;
		double m_lowerRange;
		double m_upperRange;
		double m_variance;
		double m_mean;
		int    m_nBins;
		public GaussianCDF(double mean, double variance, double lowerRange, double upperRange, int nBins){
			m_nBins      = nBins;
			m_delta      = (m_upperRange-m_lowerRange)/m_nBins;
			m_lowerRange = lowerRange;
			m_upperRange = upperRange;
			m_variance   = variance;
			m_mean       = mean;
			double[] pdfX = new double[nBins+1]; // PROBABILITY density function, NOT CDF.
			double Y = 0.0;
			double invSqrt2PiSigma = 1.0/Math.Sqrt(2*Math.PI*variance);

			m_cdfX = new double[nBins*4+1];
			for ( int i = 1 ; i <= (nBins*4) ; i++ ) {
				double x = m_lowerRange + (i*m_delta/4.0);
				double Z = Math.Pow(x-mean,2.0)/variance;
				Y = invSqrt2PiSigma*Math.Exp(-0.5*Z);
				if ( Y == 1 ) Y -= double.Epsilon;
				m_cdfX[i] = Y;
			}
		}

	#region ICDF Members

		public double GetVariate(double linear) {
			// linear is (0..1] - should assert that.

			double scala = linear*m_nBins;
			int lowerBin = (int)scala;
			double fraction = scala-lowerBin;
			double lowerX = m_cdfX[lowerBin];
			if ( fraction == 0.0 ) return lowerX;
			double upperX = m_cdfX[lowerBin+1];
			double retval = lowerX+(fraction*(upperX-lowerX));

			return retval;
		}
	#endregion
	}
	*/
    #endregion

    // http://www.itl.nist.gov/div898/handbook/eda/section3/eda366.htm

    class WeibullCDF : ICDF {
        private readonly SmallDoubleInterpolable m_sdi;

        public WeibullCDF(double gamma, int nBins) {
            double increment = 1.0 / nBins;
            double invGamma = 1.0 / gamma;
            double[] cdfY = new double[nBins + 1];
            double[] cdfX = new double[nBins + 1];
            int i;
            for (i = 0 ; i < nBins - 12 ; i++) {
                // Since we provide the Y, and expect to pull the X, we must
                // invert the CDF - i.e. insert the Y values into the x array,
                // and vice-versa. That lets us provide the Y value of the CDF into
                // the x-parameter of the GetYValue(...) call on the interpolator,
                // and receive the actual X value that would deliver that Y value.
                cdfX[i] = i * increment;
                cdfY[i] = Math.Pow(-Math.Log(1.0 - cdfX[i]), invGamma);
            }
            for (i = nBins - 12 ; i < nBins ; i++) {
                cdfX[i] = cdfX[i - 1] + ( 0.5 * ( 1 - cdfX[i - 1] ) );
                cdfY[i] = Math.Pow(-Math.Log(1.0 - cdfX[i]), invGamma);
            }

            cdfX[i] = 1.0;
            cdfY[i] = ( cdfY[i - 1] + ( 3 * ( cdfY[i - 1] - cdfY[i - 2] ) ) );

            m_sdi = new SmallDoubleInterpolable(cdfX, cdfY);

        }

        #region ICDF Members

        public double GetVariate(double linear) {
            return m_sdi.GetYValue(linear);
        }

        #endregion

    }

    class TriangularCDF : ICDF {

        #region Private Fields
        private readonly double m_lo;
        private readonly double m_hi;
        private readonly double m_pctLo;
        private readonly double m_pctHi;
        private readonly double m_loRange;
        private readonly double m_hiRange; 
        #endregion

        public TriangularCDF(double lowBound, double peak, double highBound) {
            //			m_sdi = new SmallDoubleInterpolable(3);
            //			m_sdi.SetYValue(0,lowBound);
            //			m_sdi.SetYValue(.5,peak);
            //			m_sdi.SetYValue(1.0,highBound);
            m_lo = lowBound;
            m_hi = highBound;
            m_loRange = peak - lowBound;
            m_hiRange = highBound - peak;
            m_pctLo = ( peak - lowBound ) / ( highBound - lowBound );
            m_pctHi = 1.0 - m_pctLo;
        }
        #region ICDF Members

        public double GetVariate(double linear) {
            double retval;
            if (linear <= m_pctLo) {
                linear /= m_pctLo; // back to a [0..1)
                retval = m_lo + ( Math.Sqrt(linear) * m_loRange );
            } else {
                linear = ( 1.0 - linear ) / m_pctHi; // back to a [0..1)
                retval = m_hi - ( Math.Sqrt(linear) * m_hiRange );
            }
            return retval;
        }

        #endregion

    }

    class BinomialCDF : ICDF {
        private readonly SmallDoubleInterpolable m_cdf;
        public BinomialCDF(double probability, int numberOfOpps) {
            double p = probability;
            int n = numberOfOpps;

            //			double[] xVals = new double[n+1]; // This will be [0,1];
            //			double[] yVals = new double[n+1]; // This will be [0,numberOfOpps];
            ArrayList xVals = new ArrayList();
            ArrayList yVals = new ArrayList();


            InitFactorials(numberOfOpps);
            double cumP = 0.0; // cumulative probability.
            for (int x = 0 ; x <= n ; x++) {
                double tmp = cumP + ( Factorial(n) / ( Factorial(x) * Factorial(n - x) ) ) * Math.Pow(p, x) * Math.Pow(1 - p, n - x);
                if (tmp != cumP && tmp != 1.0) {
                    yVals.Add((double)x);
                    cumP = tmp;
                    xVals.Add(cumP);
                } else {
                    yVals.Add((double)n);
                    xVals.Add(1.0);
                    break;
                }
            }

            double[] xvals = (double[])xVals.ToArray(typeof(double));
            double[] yvals = (double[])yVals.ToArray(typeof(double));
            m_cdf = new SmallDoubleInterpolable(xvals, yvals);

        }

        private double[] m_factorials;
        private void InitFactorials(int max) {
            m_factorials = new double[max + 1];
            double f = 1;
            m_factorials[0] = 1;
            for (int i = 1 ; i <= max ; i++) {
                f *= i;
                m_factorials[i] = f;
            }
        }

        private double Factorial(int x) {
            return m_factorials[x];
        }

        #region ICDF Members

        public double GetVariate(double linear) {
            return m_cdf.GetYValue(linear);
        }

        #endregion
    }
    #endregion

    /// <summary>
    /// The DistributionCatalog provides a catalog of known distributions, enabling the caller to enumerate all known
    /// distributions, or all known distributions that implement a specific interface. It reads from a section in the
    /// app config file so that it can import all distributions, or just specific distributions, from any assemblies
    /// the user desires to have included in the catalog.
    /// <p></p>
    /// The general config section impact is as follows:<p></p>
    /// 	&lt;configSections&gt; <p></p>   
    /// 		&lt;section name="Distributions" type="Highpoint.Sage.Mathematics.DistributionSectionHandler, VR_Sim" /&gt;<p></p>
    /// 	&lt;/configSections&gt;<p></p>
    /// 	&lt;Distributions&gt;<p></p>
    /// 		&lt;Library libName="VR_Sim"&gt;<p></p>
    /// 			&lt;InterfaceType typeName="Highpoint.Sage.Mathematics.IDoubleDistribution" autoImportAllImplementers="true"/&gt;<p></p>
    /// 			&lt;InterfaceType typeName="Highpoint.Sage.Mathematics.ITimeSpanDistribution" autoImportAllImplementers="true"/&gt;<p></p>
    /// 		&lt;/Library&gt;<p></p>
    /// 	&lt;/Distributions&gt;<p></p>
    /// 	If there is no config section in the config file, it initializes with all of the Sage distributions and interfaces.
    /// </summary>
    public sealed class DistributionCatalog : IEnumerable {
        private static volatile DistributionCatalog _instance;
        /// <summary>
        /// Retrieves the singleton instance of this catalog.
        /// </summary>
        public static DistributionCatalog Instance => _instance ?? (_instance = new DistributionCatalog());

        private readonly HashtableOfLists m_htol;
        private DistributionCatalog() {
            m_htol = (HashtableOfLists)System.Configuration.ConfigurationManager.GetSection("Distributions");
            if (m_htol == null) {
                m_htol = new HashtableOfLists();
                Assembly assy = GetType().Assembly;
                foreach (Type distributionInterfaceType in new[] { typeof(IDoubleDistribution), typeof(ITimeSpanDistribution) }) {
                    foreach (Type type in assy.GetTypes().Where(type => distributionInterfaceType.IsAssignableFrom(type) && !type.IsAbstract))
                    {
                        m_htol.Add(distributionInterfaceType, type);
                    }
                }
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the whole collection of Distributions.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator GetEnumerator() { return m_htol.GetEnumerator(); }

        /// <summary>
        /// Gets a collection of all of the known interfaces.
        /// </summary>
        /// <value>The known interfaces.</value>
        public ICollection KnownInterfaces => m_htol.Keys;

        /// <summary>
        /// Gets the distributions that implement a given interface such as ITimeSpanDistribution.
        /// </summary>
        /// <param name="iEnumeratorType">Type of the enumerator.</param>
        /// <returns></returns>
        public IList GetDistributionsForInterface(Type iEnumeratorType) {
            object obj = m_htol[iEnumeratorType];
            if (obj != null) return (IList)obj;
            return new ArrayList();
        }

    }

    internal class DistributionSectionHandler : System.Configuration.IConfigurationSectionHandler
    {
        private static bool _defaultAutoImportSetting = true;
        private HashtableOfLists m_distributions;

        #region IConfigurationSectionHandler Members

        public object Create(object parent, object configContext, XmlNode section)
        {
            if (m_distributions == null)
            {
                m_distributions = new HashtableOfLists();

                XmlNodeList xmlNodeList = section.SelectNodes("Library");
                if (xmlNodeList != null)
                    foreach (XmlNode libNode in xmlNodeList)
                    {
                        if (libNode.Attributes != null)
                        {
                            XmlAttribute assemblyStringAttr = libNode.Attributes["libName"];
                            if (assemblyStringAttr == null)
                                throw new ApplicationException(
                                    "Missing \"Library\" attribute in Distribution Section Handler in Config File.");
                            string assemblyString = assemblyStringAttr.InnerText;
                            Assembly assy = Assembly.Load(assemblyString);

                            XmlNodeList distroIfTypeNodes = libNode.SelectNodes("InterfaceType");
                            if (distroIfTypeNodes != null)
                                foreach (XmlNode distroIfTypeNode in distroIfTypeNodes)
                                {
                                    if (distroIfTypeNode.Attributes == null) continue;

                                    XmlAttribute distroIfTypeNameAttr = distroIfTypeNode.Attributes["typeName"];
                                    string distroIfTypeName = distroIfTypeNameAttr.InnerText;
                                    Type distributionInterfaceType = assy.GetType(distroIfTypeName, false);
                                    if (distributionInterfaceType == null) continue;

                                    XmlAttribute autoImportAttr =
                                        distroIfTypeNode.Attributes["autoImportAllImplementers"];
                                    bool autoImport = autoImportAttr == null
                                        ? _defaultAutoImportSetting
                                        : XmlConvert.ToBoolean(autoImportAttr.InnerText);
                                    if (!autoImport) continue;

                                    foreach (Type type in assy.GetTypes().Where(type => distributionInterfaceType.IsAssignableFrom(type) &&
                                                                                        !type.IsAbstract))
                                    {
                                        m_distributions.Add(distributionInterfaceType, type);
                                    }
                                }
                        }
                    }
            }
            return m_distributions;
        }

        #endregion
    }

    /// <summary>
    /// An attribute that decorates any class that can have a distribution as a member.
    /// </summary>
    public class SupportsDistributionsAttribute : Attribute {

        #region Private Fields

        private readonly Type m_distroInterface;
        private readonly string m_whereToPutTheDistribution;

        #endregion

        /// <summary>
        /// Creates a new instance of the <see cref="T:SupportsDistributionsAttribute"/> class.
        /// </summary>
        /// <param name="distributionInterface">The distribution interface that is implemented by the member in the decorated class.</param>
        /// <param name="memberNameOfDistribution">The member name  in the decorated class, of the distribution.</param>
        public SupportsDistributionsAttribute(Type distributionInterface, string memberNameOfDistribution) {
            m_distroInterface = distributionInterface;
            m_whereToPutTheDistribution = memberNameOfDistribution;
        }

        /// <summary>
        /// Gets a list of Distribution types that are candidates for the declared member of the class that is decorated by this attribute.
        /// </summary>
        /// <returns></returns>
        public IList GetCandidateTypes() {
            return DistributionCatalog.Instance.GetDistributionsForInterface(m_distroInterface);
        }

        /// <summary>
        /// Sets the value of the declared member of the target object (which is an instance of the decorated class) to a provided distribution.
        /// </summary>
        /// <param name="target">The target object.</param>
        /// <param name="distro">The distribution.</param>
        public void SetDistribution(object target, object distro) {
            BindingFlags bindingAttr = BindingFlags.FlattenHierarchy | BindingFlags.Instance | BindingFlags.GetField | BindingFlags.NonPublic;
            //MemberInfo mi = target.GetType().GetMember(m_whereToPutTheDistribution,bindingAttr);
            FieldInfo fi = target.GetType().GetField(m_whereToPutTheDistribution, bindingAttr);

            fi?.SetValue(target, distro);
        }
    }

    static class PoissonCDFLookupTable
    {
        public static List<double> ForLambda(double lambda)
        {
            if (lambda < .1) return null; // Use computational approach.
            if (lambda > 15) return null; // Use normal CDF.
            LinearDoubleInterpolator ldi = new LinearDoubleInterpolator();
            ldi.SetData(lambdas, indices);
            double col = ldi.GetYValue(lambda);

            int f = (int)Math.Floor(col);
            int c = (int)Math.Ceiling(col);

            List<double> retval = new List<double>();
            for (int i = 0; i < lut.GetLength(0); i++)
            {
                retval.Add((lut[i, f] + lut[i, c]) / 2.0);
                // ReSharper disable once CompareOfFloatsByEqualityOperator
                if (lut[i, c] == 1.0) break;
            }
            return retval;
        }

        private static double[] indices = new double[]
        {
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
                29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46
        };

        private static double[] lambdas = new double[]
        {
            0.100000000, 0.200000000, 0.300000000, 0.400000000, 0.500000000, 0.600000000, 0.700000000,
            0.800000000, 0.900000000, 1.000000000, 1.200000000, 1.400000000, 1.600000000, 1.800000000, 2.000000000,
            2.200000000, 2.400000000, 2.600000000, 2.800000000, 3.000000000, 3.200000000, 3.400000000, 3.600000000,
            3.800000000, 4.000000000, 4.500000000, 5.000000000, 5.500000000, 6.000000000, 6.500000000, 7.000000000,
            7.500000000, 8.000000000, 8.500000000, 9.000000000, 9.500000000, 10.000000000, 10.500000000, 11.000000000,
            11.500000000, 12.000000000, 12.500000000, 13.000000000, 13.500000000, 14.000000000, 14.500000000, 15.000000000
        };

        private static double[,] lut = new double[,]
        {
            {
                0.9048374, 0.8187308, 0.7408182, 0.6703200, 0.6065307, 0.5488116, 0.4965853, 0.4493290, 0.4065697,
                0.3678794, 0.3011942, 0.2465970, 0.2018965, 0.1652989, 0.1353353, 0.1108032, 0.0907180, 0.0742736,
                0.0608101, 0.0497871, 0.0407622, 0.0333733, 0.0273237, 0.0223708, 0.0183156, 0.0111090, 0.0067379,
                0.0040868, 0.0024788, 0.0015034, 0.0009119, 0.0005531, 0.0003355, 0.0002035, 0.0001234, 0.0000749,
                0.0000454, 0.0000275, 0.0000167, 0.0000101, 0.0000061, 0.0000037, 0.0000023, 0.0000014, 0.0000008,
                0.0000005, 0.0000003
            },
            {
                0.9953212, 0.9824769, 0.9630637, 0.9384481, 0.9097960, 0.8780986, 0.8441950, 0.8087921, 0.7724824,
                0.7357589, 0.6626273, 0.5918327, 0.5249309, 0.4628369, 0.4060058, 0.3545701, 0.3084410, 0.2673849,
                0.2310782, 0.1991483, 0.1712013, 0.1468424, 0.1256891, 0.1073797, 0.0915782, 0.0610995, 0.0404277,
                0.0265640, 0.0173513, 0.0112758, 0.0072951, 0.0047012, 0.0030192, 0.0019329, 0.0012341, 0.0007859,
                0.0004994, 0.0003167, 0.0002004, 0.0001266, 0.0000799, 0.0000503, 0.0000316, 0.0000199, 0.0000125,
                0.0000078, 0.0000049
            },
            {
                0.9998453, 0.9988515, 0.9964005, 0.9920737, 0.9856123, 0.9768847, 0.9658584, 0.9525774, 0.9371431,
                0.9196986, 0.8794871, 0.8334977, 0.7833585, 0.7306211, 0.6766764, 0.6227137, 0.5697087, 0.5184296,
                0.4694537, 0.4231901, 0.3799037, 0.3397399, 0.3027468, 0.2688967, 0.2381033, 0.1735781, 0.1246520,
                0.0883764, 0.0619688, 0.0430359, 0.0296362, 0.0202567, 0.0137540, 0.0092832, 0.0062322, 0.0041636,
                0.0027694, 0.0018346, 0.0012109, 0.0007965, 0.0005223, 0.0003415, 0.0002226, 0.0001448, 0.0000940,
                0.0000608, 0.0000393
            },
            {
                0.9999962, 0.9999432, 0.9997342, 0.9992237, 0.9982484, 0.9966419, 0.9942465, 0.9909201, 0.9865413,
                0.9810118, 0.9662310, 0.9462747, 0.9211865, 0.8912916, 0.8571235, 0.8193524, 0.7787229, 0.7360016,
                0.6919374, 0.6472319, 0.6025197, 0.5583571, 0.5152161, 0.4734848, 0.4334701, 0.3422960, 0.2650259,
                0.2016992, 0.1512039, 0.1118496, 0.0817654, 0.0591455, 0.0423801, 0.0301091, 0.0212265, 0.0148596,
                0.0103361, 0.0071474, 0.0049159, 0.0033642, 0.0022918, 0.0015546, 0.0010503, 0.0007070, 0.0004742,
                0.0003171, 0.0002114
            },
            {
                0.9999999, 0.9999977, 0.9999842, 0.9999388, 0.9998279, 0.9996055, 0.9992145, 0.9985887, 0.9976559,
                0.9963402, 0.9922542, 0.9857467, 0.9763177, 0.9635933, 0.9473470, 0.9275037, 0.9041314, 0.8774235,
                0.8476761, 0.8152632, 0.7806125, 0.7441816, 0.7064384, 0.6678436, 0.6288369, 0.5321036, 0.4404933,
                0.3575180, 0.2850565, 0.2236718, 0.1729916, 0.1320619, 0.0996324, 0.0743640, 0.0549636, 0.0402627,
                0.0292527, 0.0210936, 0.0151046, 0.0107466, 0.0076004, 0.0053455, 0.0037402, 0.0026043, 0.0018052,
                0.0012460, 0.0008566
            },
            {
                1.0000000, 0.9999999, 0.9999992, 0.9999960, 0.9999858, 0.9999611, 0.9999100, 0.9998157, 0.9996565,
                0.9994058, 0.9984998, 0.9967989, 0.9939597, 0.9896220, 0.9834364, 0.9750902, 0.9643275, 0.9509628,
                0.9348897, 0.9160821, 0.8945919, 0.8705424, 0.8441185, 0.8155563, 0.7851304, 0.7029304, 0.6159607,
                0.5289187, 0.4456796, 0.3690407, 0.3007083, 0.2414365, 0.1912361, 0.1495973, 0.1156905, 0.0885284,
                0.0670860, 0.0503805, 0.0375198, 0.0277259, 0.0203410, 0.0148229, 0.0107339, 0.0077272, 0.0055320,
                0.0039400, 0.0027924
            },
            {
                1.0000000, 1.0000000, 1.0000000, 0.9999998, 0.9999990, 0.9999967, 0.9999911, 0.9999793, 0.9999566,
                0.9999168, 0.9997489, 0.9993777, 0.9986642, 0.9974306, 0.9954662, 0.9925387, 0.9884059, 0.9828299,
                0.9755894, 0.9664915, 0.9553809, 0.9421468, 0.9267266, 0.9091076, 0.8893260, 0.8310506, 0.7621835,
                0.6860360, 0.6063028, 0.5265236, 0.4497111, 0.3781547, 0.3133743, 0.2561779, 0.2067808, 0.1649492,
                0.1301414, 0.1016325, 0.0786144, 0.0602697, 0.0458223, 0.0345674, 0.0258869, 0.0192536, 0.0142279,
                0.0104504, 0.0076319
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999998, 0.9999992, 0.9999979, 0.9999952,
                0.9999898, 0.9999630, 0.9998935, 0.9997396, 0.9994385, 0.9989033, 0.9980224, 0.9966614, 0.9946662,
                0.9918693, 0.9880955, 0.9831702, 0.9769261, 0.9692107, 0.9598926, 0.9488664, 0.9134135, 0.8666283,
                0.8094853, 0.7439798, 0.6727578, 0.5987138, 0.5246385, 0.4529608, 0.3855971, 0.3238970, 0.2686632,
                0.2202206, 0.1785106, 0.1431915, 0.1137345, 0.0895045, 0.0698255, 0.0540282, 0.0414832, 0.0316197,
                0.0239361, 0.0180022
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999998, 0.9999995,
                0.9999989, 0.9999951, 0.9999837, 0.9999546, 0.9998903, 0.9997626, 0.9995305, 0.9991380, 0.9985130,
                0.9975672, 0.9961970, 0.9942859, 0.9917073, 0.9883286, 0.9840155, 0.9786366, 0.9597427, 0.9319064,
                0.8943567, 0.8472375, 0.7915730, 0.7290913, 0.6619671, 0.5925473, 0.5231050, 0.4556526, 0.3918235,
                0.3328197, 0.2794130, 0.2319851, 0.1905901, 0.1550278, 0.1249162, 0.0997579, 0.0789955, 0.0620552,
                0.0483791, 0.0374465
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                0.9999999, 0.9999994, 0.9999978, 0.9999929, 0.9999806, 0.9999535, 0.9998991, 0.9997985, 0.9996243,
                0.9993399, 0.9988975, 0.9982381, 0.9972913, 0.9959757, 0.9942007, 0.9918678, 0.9829073, 0.9681719,
                0.9462225, 0.9160760, 0.8773840, 0.8304959, 0.7764076, 0.7166243, 0.6529737, 0.5874082, 0.5218260,
                0.4579297, 0.3971326, 0.3405106, 0.2887945, 0.2423922, 0.2014311, 0.1658119, 0.1352640, 0.1093994,
                0.0877594, 0.0698537
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 0.9999999, 0.9999997, 0.9999990, 0.9999969, 0.9999917, 0.9999802, 0.9999570, 0.9999133,
                0.9998363, 0.9997077, 0.9995028, 0.9991898, 0.9987287, 0.9980711, 0.9971602, 0.9933313, 0.9863047,
                0.9747487, 0.9573791, 0.9331612, 0.9014792, 0.8622380, 0.8158858, 0.7633620, 0.7059883, 0.6453284,
                0.5830398, 0.5207381, 0.4598887, 0.4017296, 0.3472294, 0.2970747, 0.2516820, 0.2112265, 0.1756812,
                0.1448608, 0.1184644
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999995, 0.9999986, 0.9999964, 0.9999915, 0.9999816,
                0.9999626, 0.9999286, 0.9998708, 0.9997767, 0.9996297, 0.9994081, 0.9990848, 0.9975957, 0.9945469,
                0.9890119, 0.9799080, 0.9661204, 0.9466504, 0.9207587, 0.8880760, 0.8486620, 0.8030084, 0.7519896,
                0.6967761, 0.6387252, 0.5792668, 0.5197981, 0.4615973, 0.4057607, 0.3531649, 0.3044532, 0.2600399,
                0.2201309, 0.1847518
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999998, 0.9999994, 0.9999985, 0.9999964,
                0.9999921, 0.9999839, 0.9999689, 0.9999429, 0.9999000, 0.9998315, 0.9997263, 0.9991949, 0.9979811,
                0.9955491, 0.9911725, 0.9839734, 0.9730002, 0.9573341, 0.9362028, 0.9090829, 0.8757734, 0.8364297,
                0.7915565, 0.7419639, 0.6886967, 0.6329471, 0.5759652, 0.5189752, 0.4631047, 0.4093332, 0.3584584,
                0.3110822, 0.2676110
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997, 0.9999993,
                0.9999984, 0.9999966, 0.9999930, 0.9999864, 0.9999748, 0.9999553, 0.9999237, 0.9997484, 0.9993020,
                0.9983149, 0.9963715, 0.9928998, 0.9871886, 0.9784353, 0.9658193, 0.9485889, 0.9261492, 0.8981359,
                0.8644644, 0.8253490, 0.7812912, 0.7330404, 0.6815356, 0.6278353, 0.5730446, 0.5182470, 0.4644476,
                0.4125279, 0.3632178
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999,
                0.9999997, 0.9999993, 0.9999985, 0.9999970, 0.9999941, 0.9999889, 0.9999801, 0.9999263, 0.9997737,
                0.9994014, 0.9985996, 0.9970442, 0.9942828, 0.9897396, 0.9827430, 0.9725746, 0.9585337, 0.9400080,
                0.9165415, 0.8878879, 0.8540440, 0.8152599, 0.7720245, 0.7250319, 0.6751315, 0.6232711, 0.5704367,
                0.5175967, 0.4656537
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 0.9999999, 0.9999997, 0.9999994, 0.9999987, 0.9999974, 0.9999951, 0.9999797, 0.9999310,
                0.9997998, 0.9994909, 0.9988402, 0.9975934, 0.9953917, 0.9917690, 0.9861666, 0.9779643, 0.9665270,
                0.9512596, 0.9316651, 0.9073961, 0.8782948, 0.8444157, 0.8060290, 0.7636069, 0.7177928, 0.6693599,
                0.6191632, 0.5680896
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 0.9999999, 0.9999999, 0.9999997, 0.9999994, 0.9999989, 0.9999947, 0.9999801,
                0.9999368, 0.9998251, 0.9995698, 0.9990418, 0.9980411, 0.9962820, 0.9933873, 0.9888941, 0.9822726,
                0.9729584, 0.9603938, 0.9440756, 0.9236012, 0.8987090, 0.8693080, 0.8354931, 0.7975455, 0.7559177,
                0.7112078, 0.6641232
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999999, 0.9999998, 0.9999987, 0.9999946,
                0.9999811, 0.9999431, 0.9998487, 0.9996382, 0.9992100, 0.9984057, 0.9969976, 0.9946804, 0.9910717,
                0.9857224, 0.9781381, 0.9678095, 0.9542496, 0.9370337, 0.9158367, 0.8904650, 0.8608785, 0.8272006,
                0.7897165, 0.7488588
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997, 0.9999986,
                0.9999946, 0.9999824, 0.9999495, 0.9998701, 0.9996970, 0.9993496, 0.9987025, 0.9975736, 0.9957156,
                0.9928135, 0.9884889, 0.9823135, 0.9738306, 0.9625835, 0.9481483, 0.9301669, 0.9083782, 0.8826429,
                0.8529596, 0.8194717
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997,
                0.9999985, 0.9999948, 0.9999839, 0.9999556, 0.9998893, 0.9997471, 0.9994653, 0.9989440, 0.9980376,
                0.9965457, 0.9942091, 0.9907105, 0.9856822, 0.9787202, 0.9694059, 0.9573313, 0.9421280, 0.9234951,
                0.9012240, 0.8752188
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999,
                0.9999996, 0.9999985, 0.9999951, 0.9999855, 0.9999613, 0.9999060, 0.9997894, 0.9995607, 0.9991405,
                0.9984117, 0.9972122, 0.9953289, 0.9924969, 0.9884023, 0.9826919, 0.9749882, 0.9649092, 0.9520916,
                0.9362157, 0.9170291
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                0.9999999, 0.9999996, 0.9999986, 0.9999955, 0.9999871, 0.9999666, 0.9999206, 0.9998250, 0.9996395,
                0.9993003, 0.9987137, 0.9977481, 0.9962287, 0.9939349, 0.9906002, 0.9859186, 0.9795542, 0.9711559,
                0.9603767, 0.9468936
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 0.9999999, 0.9999996, 0.9999986, 0.9999959, 0.9999886, 0.9999713, 0.9999332, 0.9998549,
                0.9997043, 0.9994304, 0.9989577, 0.9981795, 0.9969526, 0.9950936, 0.9923775, 0.9885409, 0.9832878,
                0.9763010, 0.9672558
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 0.9999999, 0.9999996, 0.9999987, 0.9999963, 0.9999900, 0.9999755, 0.9999439,
                0.9998799, 0.9997575, 0.9995361, 0.9991548, 0.9985271, 0.9975356, 0.9960282, 0.9938157, 0.9906724,
                0.9863402, 0.9805354
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999996, 0.9999988, 0.9999967, 0.9999913, 0.9999791,
                0.9999531, 0.9999007, 0.9998013, 0.9996222, 0.9993144, 0.9988076, 0.9980057, 0.9967828, 0.9949801,
                0.9924055, 0.9888352
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999996, 0.9999989, 0.9999971, 0.9999925,
                0.9999823, 0.9999608, 0.9999179, 0.9998372, 0.9996922, 0.9994435, 0.9990340, 0.9983850, 0.9973924,
                0.9959234, 0.9938151
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997, 0.9999990, 0.9999974,
                0.9999936, 0.9999851, 0.9999673, 0.9999323, 0.9998667, 0.9997492, 0.9995481, 0.9992169, 0.9986913,
                0.9978854, 0.9966881
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997, 0.9999991,
                0.9999977, 0.9999945, 0.9999874, 0.9999728, 0.9999442, 0.9998908, 0.9997957, 0.9996329, 0.9993649,
                0.9989390, 0.9982842
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997,
                0.9999992, 0.9999980, 0.9999953, 0.9999894, 0.9999774, 0.9999540, 0.9999106, 0.9998334, 0.9997016,
                0.9994846, 0.9991393
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999,
                0.9999997, 0.9999993, 0.9999983, 0.9999960, 0.9999911, 0.9999812, 0.9999621, 0.9999268, 0.9998642,
                0.9997574, 0.9995816
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                0.9999999, 0.9999998, 0.9999994, 0.9999985, 0.9999966, 0.9999926, 0.9999844, 0.9999688, 0.9999401,
                0.9998893, 0.9998027
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 0.9999999, 0.9999998, 0.9999995, 0.9999988, 0.9999972, 0.9999938, 0.9999871, 0.9999743,
                0.9999509, 0.9999097
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 0.9999999, 0.9999998, 0.9999996, 0.9999989, 0.9999976, 0.9999948, 0.9999893,
                0.9999789, 0.9999598
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999998, 0.9999996, 0.9999991, 0.9999980, 0.9999957,
                0.9999912, 0.9999826
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999999, 0.9999997, 0.9999992, 0.9999983,
                0.9999964, 0.9999927
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999997, 0.9999994,
                0.9999986, 0.9999970
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999, 0.9999998,
                0.9999995, 0.9999988
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 0.9999999,
                0.9999998, 0.9999995
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                0.9999999, 0.9999998
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 0.9999999
            },
            {
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000,
                1.0000000, 1.0000000
            }
        };
    }

}